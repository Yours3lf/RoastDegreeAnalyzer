<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <style>

    </style>
</head>

<body>
    <div style="position: absolute; left: 300; top: 30;">
        <div id="fileSaveDiv">
            <input type="text" placeholder="Filename" readonly="readonly" onclick="pickSaveFile()" id="fileSavePath" />
            <button onclick="saveRoastAnalysis()">Save</button>
        </div>
        <div id="fileLoadDiv">
            <input type="text" placeholder="Filename" readonly="readonly"
                onclick="document.getElementById('filePicker').click();" id="fileLoadPath" />
            <input type="file" id="filePicker" accept=".roast" style="display:none;"
                onchange="document.getElementById('fileLoadPath').value = this.files[0].name; fileToLoad = this.files[0];" />
            <button onclick="loadRoastAnalysis()">Load</button>
        </div>
        <button id="captureButton" style="display:none;" onclick="capture()">Capture</button>
        <button id="analyzeButton" style="display:none;" onclick="analyze()">Analyze</button>
        <button id="viewFinderButton" style="display:none;" onclick="viewFinder()">ViewFinder</button>
        <button id="connectButton" onclick="connect(document.getElementById('serverURL').value)">Connect</button>
        <button id="disconnectButton" style="display:none;" onclick="disconnect()">Disconnect</button>
        <input id="serverURL" type="text" value="ws://192.168.1.98:50000" />
        <input id="circleX" title="X" type="range" style="display:none;" min="0" max="100" value="46.5" step="0.5" />
        <input id="circleY" title="Y" type="range" style="display:none;" min="0" max="100" value="56" step="0.5" />
        <input id="circleSize" title="Size" type="range" style="display:none;" min="0" max="100" value="42.5"
            step="0.5" />
        <div id="minVal"></div>
        <div id="maxVal"></div>
        <div id="meanVal"></div>
        <div id="avgVal"></div>
        <div id="top20AvgVal"></div>
        <div id="agtronVal"></div>
    </div>
    <canvas id="camOutput"></canvas>
    <canvas id="histogram" style="display:none;"></canvas>


    <script>
        "use strict";

        let webSocket = null;
        let stillImageBuf = null;
        let viewFinderBuf = null;

        let fileToLoad = null;
        let fileToSave = null;

        //this needs to be calibrated to the camera's exposure time settings
        //currently it's for 40ms expoure
        //reference cards measured mean values of sample area
        //R55 measures 288 for some reason...
        const r25 = 115; 
        const r35 = 125;
        const r45 = 140;  
        const r55 = 180; 
        const r65 = 220;
        const r75 = 235; 
        const r85 = 245; 
        const r95 = 255; 

        //Estimate Agtron value given an input measurement
        //uses above calibration
        function getAgtronValue(x) {
            return 0.000073 * x**3 + -0.039923 * x**2 + 7.377896 * x + -406.972289;            
        }

        async function pickSaveFile() {
            fileToSave = await window.showSaveFilePicker({
                types: [{
                    description: "ROAST file",
                    accept: { "application/octet-stream": [".roast"] }
                }]
            });
            let file = await fileToSave.getFile();
            document.getElementById('fileSavePath').value = file.name;
        }

        async function saveRoastAnalysis() {
            if (fileToSave != null) {
                try {
                    const fileStream = await fileToSave.createWritable();
                    let outBuf = new ArrayBuffer(stillImageBuf.byteLength + 3 * 4);
                    let outBuf32 = new Uint32Array(outBuf);
                    outBuf32[0] = document.getElementById("circleX").value;
                    outBuf32[1] = document.getElementById("circleY").value;
                    outBuf32[2] = document.getElementById("circleSize").value;
                    new Uint8Array(outBuf).set(new Uint8Array(stillImageBuf), 3 * 4);

                    await fileStream.write(new Blob([outBuf], { type: "application/octet-stream" }));
                    await fileStream.close();
                }
                catch (e) {
                    console.error(e);
                }
            }
        }

        function loadRoastAnalysis() {
            if (fileToLoad != null) {
                try {
                    let reader = new FileReader();
                    reader.readAsArrayBuffer(fileToLoad);
                    reader.onload = function (evt) {
                        let circleBuf = new Uint32Array(reader.result);
                        let imageBuf = new Uint8Array(reader.result, 3 * 4);

                        stillImageBuf = new ArrayBuffer(imageBuf.byteLength);
                        new Uint8Array(stillImageBuf).set(imageBuf);

                        document.getElementById("circleX").value = circleBuf[0];
                        document.getElementById("circleY").value = circleBuf[1];
                        document.getElementById("circleSize").value = circleBuf[2];

                        let canvas = document.getElementById("histogram");
                        let ctx = canvas.getContext("2d");
                        ctx.reset();

                        document.getElementById("circleX").style.display = "none";
                        document.getElementById("circleY").style.display = "none";
                        document.getElementById("circleSize").style.display = "none";
                        document.getElementById("captureButton").style.display = "none";
                        document.getElementById("viewFinderButton").style.display = "inline-block";
                        document.getElementById("analyzeButton").style.display = "inline-block";

                        document.getElementById("camOutput").style.display = "none";
                        document.getElementById("histogram").style.display = "block";

                        handleCapture(stillImageBuf, true);
                    }
                }
                catch (e) {
                    console.error(e);
                }
            }
        }

        function scaleCanvas(id, width, height, keepAspectRatio = true) {
            let canvas = document.getElementById(id);
            const scale = window.devicePixelRatio;
            canvas.width = width * scale;
            canvas.height = height * scale;

            //reset style first
            canvas.style.width = "";
            canvas.style.height = "";
            canvas.style.maxWidth = "";
            canvas.style.maxHeight = "";
            canvas.style.aspectRatio = "";

            if (keepAspectRatio) {
                //canvas.style.maxWidth = "100%";
                //canvas.style.width = `${width}px`; // CSS size
                canvas.style.height = `${height}px`;
                canvas.style.maxHeight = "100%";
                canvas.style.aspectRatio = width / height;
            }
            else {
                canvas.style.width = `${width}px`; // CSS size
                canvas.style.height = `${height}px`;
                canvas.style.maxHeight = "100%";
                canvas.style.maxWidth = "100%";
            }
            let ctx = canvas.getContext("2d");
            ctx.reset();
        }

        function visualiseRawImage(stillImage, width, height, maxVal) {
            let circleX = document.getElementById("circleX").value * width / 100;
            let circleY = document.getElementById("circleY").value * height / 100;
            let diameter = document.getElementById("circleSize").value * height / 100;

            let stillImageNormalized = new Uint8ClampedArray(stillImage.length * 4);

            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    let idx = y * width + x;

                    let val = stillImage[idx];
                    let normValR = val <= (maxVal - 1) ? (val / maxVal) * 255 : 255;
                    let normValG = val <= (maxVal - 1) ? normValR : 0;
                    let normValB = val <= (maxVal - 1) ? normValR : 0;

                    if (withinCircle(x, y, circleX, circleY, diameter)) {
                        normValR = Math.min(normValR * 2, 255);
                    }

                    stillImageNormalized[idx * 4 + 0] = normValR;
                    stillImageNormalized[idx * 4 + 1] = normValG;
                    stillImageNormalized[idx * 4 + 2] = normValB;
                    stillImageNormalized[idx * 4 + 3] = 255;
                }
            }

            //debug draw image data
            const imageData = new ImageData(stillImageNormalized, width, height, { colorSpace: "srgb" });
            const imageBitmap = window.createImageBitmap(imageData);

            imageBitmap.then(function (bitmap) {
                let canvas = document.getElementById("histogram");
                let ctx = canvas.getContext("2d");
                ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
                bitmap.close();
                drawCircle(canvas, document.getElementById("circleX").value * canvas.width / 100, document.getElementById("circleY").value * canvas.height / 100, document.getElementById("circleSize").value * canvas.height / 100);
            });
        }

        function drawCircle(canvas, x, y, d) {
            let ctx = canvas.getContext("2d");
            ctx.strokeStyle = "red";
            ctx.beginPath();
            ctx.arc(x, y, d / 2, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function withinCircle(x, y, circleX, circleY, diameter) {
            let radius = diameter / 2;

            let diffX = x - circleX;
            let diffY = y - circleY;

            return (diffX * diffX + diffY * diffY) < (radius * radius);
        }

        function drawHistogram(stillImage, width, height, maxVal) {
            let circleX = document.getElementById("circleX").value * width / 100;
            let circleY = document.getElementById("circleY").value * height / 100;
            let diameter = document.getElementById("circleSize").value * height / 100;

            let min = maxVal;
            let max = 0;
            let avg = 0;
            let counter = 0;
            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (!withinCircle(x, y, circleX, circleY, diameter)) continue;

                    let idx = y * width + x;
                    let val = stillImage[idx];

                    if (val >= maxVal) continue;

                    min = Math.min(val, min);
                    max = Math.max(val, max);
                    avg += val;
                    counter++;
                }
            }
            avg /= counter;

            let histogram = new Map();
            for (let x = Math.floor(min); x <= Math.floor(max); ++x) {
                histogram.set(x, 0);
            }

            for (let y = 0; y < height; ++y) {
                for (let x = 0; x < width; ++x) {
                    if (!withinCircle(x, y, circleX, circleY, diameter)) continue;

                    let idx = y * width + x;

                    if (stillImage[idx] >= maxVal) continue;

                    histogram.set(Math.floor(stillImage[idx]), histogram.get(Math.floor(stillImage[idx])) + 1);
                }
            }

            let mostFrequentVal = 0;
            let mostFrequentKey = 0;
            for (const [key, val] of histogram) {
                if (mostFrequentVal < val) {
                    mostFrequentVal = val;
                    mostFrequentKey = key;
                }
            }

            let numConsidered = 20;
            let sortedArray = Array.from(histogram.entries());
            sortedArray = sortedArray.sort(function(a, b){
                if(a[1] < b[1]) return 1;
                if(a[1] > b[1]) return -1;
                if(a[1] == b[1]) return 0;
            });

            let candidate = 0;
            for(let i = 0; i < numConsidered; i++){ 
                candidate += sortedArray[i][0];
            }
            candidate /= numConsidered;

            let canvas = document.getElementById("histogram");
            let ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let barCounter = 0;
            let barwidth = canvas.width / histogram.size;
            for (const [key, val] of histogram) {
                if (Math.abs(key - min) < 2){
                    ctx.fillStyle = "#000000";
                }
                else if(Math.abs(key - max) < 2){
                    ctx.fillStyle = "#ffffff";
                }
                else if(Math.abs(key - avg) < 2){
                    ctx.fillStyle = "#ff0000";
                }
                else if(Math.abs(key - mostFrequentKey) < 2){
                    ctx.fillStyle = "#ffff00";
                }
                else if(Math.abs(key - candidate) < 2){
                    ctx.fillStyle = "#00ff00";
                }
                else {
                    ctx.fillStyle = "#555";
                }

                ctx.fillRect(
                    (barwidth) * barCounter,
                    (1.0 - val / mostFrequentVal) * canvas.height,
                    barwidth,
                    val / mostFrequentVal * canvas.height);
                barCounter++;
            }

            document.getElementById("minVal").innerHTML = "Min: " + min;
            document.getElementById("maxVal").innerHTML = "Max: " + max;
            document.getElementById("meanVal").innerHTML = "Mean: " + mostFrequentKey;
            document.getElementById("avgVal").innerHTML = "Avg: " + avg.toFixed(2);
            document.getElementById("top20AvgVal").innerHTML = "Top " + numConsidered + " avg: " + candidate.toFixed(2);
            document.getElementById("agtronVal").innerHTML = "Agtron R" + Math.floor(getAgtronValue(avg));
        }

        function handleCapture(arrayBuf, visualiseStillImage = true) {
            let uint32Array = new Uint32Array(arrayBuf, 0, 5);

            let type = uint32Array[0];
            let size = uint32Array[1];
            let width = uint32Array[2];
            let height = uint32Array[3];
            let maxVal = uint32Array[4];

            if (type == 1) //viewFinder
            {
                viewFinderBuf = arrayBuf;

                let viewFinderImage = new Uint8ClampedArray(arrayBuf, 5 * 4, size);

                const imageData = new ImageData(viewFinderImage, width, height, { colorSpace: "srgb" });
                const imageBitmap = window.createImageBitmap(imageData);

                scaleCanvas("camOutput", width, height);

                imageBitmap.then(function (bitmap) {
                    let canvas = document.getElementById("camOutput");
                    let ctx = canvas.getContext("2d");
                    ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
                    bitmap.close();
                    drawCircle(canvas, document.getElementById("circleX").value * canvas.width / 100, document.getElementById("circleY").value * canvas.height / 100, document.getElementById("circleSize").value * canvas.height / 100);
                });
            }
            else if (type == 2) //still capture
            {
                stillImageBuf = arrayBuf;

                let stillImage = new Uint16Array(arrayBuf, 5 * 4, size / 2);

                if (visualiseStillImage) {
                    scaleCanvas("histogram", width, height, true);
                    visualiseRawImage(stillImage, width, height, maxVal);
                }
                else {
                    scaleCanvas("histogram", width, height, false);
                    drawHistogram(stillImage, width, height, maxVal);
                }
            }
        }

        function viewFinder() {
            document.getElementById("viewFinderButton").style.display = "none";
            document.getElementById("circleX").style.display = "block";
            document.getElementById("circleY").style.display = "block";
            document.getElementById("circleSize").style.display = "block";
            document.getElementById("captureButton").style.display = "inline-block";

            document.getElementById("camOutput").style.display = "block";
            document.getElementById("histogram").style.display = "none";

            document.getElementById("minVal").innerHTML = "";
            document.getElementById("maxVal").innerHTML = "";
            document.getElementById("meanVal").innerHTML = "";
            document.getElementById("avgVal").innerHTML = "";
            document.getElementById("top20AvgVal").innerHTML = "";
            document.getElementById("agtronVal").innerHTML = "";

            handleCapture(viewFinderBuf, true);
        }

        function analyze() {
            document.getElementById("analyzeButton").style.display = "none";

            document.getElementById("camOutput").style.display = "none";
            document.getElementById("histogram").style.display = "block";

            handleCapture(stillImageBuf, false);
        }

        function capture() {
            let canvas = document.getElementById("histogram");
            let ctx = canvas.getContext("2d");
            ctx.reset();

            document.getElementById("circleX").style.display = "none";
            document.getElementById("circleY").style.display = "none";
            document.getElementById("circleSize").style.display = "none";
            document.getElementById("captureButton").style.display = "none";
            document.getElementById("viewFinderButton").style.display = "inline-block";
            document.getElementById("analyzeButton").style.display = "inline-block";

            document.getElementById("camOutput").style.display = "none";
            document.getElementById("histogram").style.display = "block";

            if (webSocket) {
                webSocket.send("capture");
            }
        }

        function disconnect() {
            webSocket.close();
            document.getElementById("serverURL").style.display = "inline-block";
            document.getElementById("connectButton").style.display = "inline-block";
            document.getElementById("disconnectButton").style.display = "none";
            document.getElementById("captureButton").style.display = "none";
            document.getElementById("analyzeButton").style.display = "none";
            document.getElementById("circleX").style.display = "none";
            document.getElementById("circleY").style.display = "none";
            document.getElementById("circleSize").style.display = "none";
        }

        function connect(serverURL) {
            try {
                webSocket = new WebSocket(serverURL);
                webSocket.binaryType = 'arraybuffer';

                webSocket.onerror = (event) => {
                    console.error("Failed to connect to " + serverURL);
                }

                webSocket.onclose = (event) => {
                    console.log("Connection closed");
                }

                webSocket.onopen = (event) => {
                    console.log("Connection opened successfully");
                    document.getElementById("serverURL").style.display = "none";
                    document.getElementById("connectButton").style.display = "none";
                    document.getElementById("disconnectButton").style.display = "inline-block";
                    document.getElementById("captureButton").style.display = "inline-block";
                    document.getElementById("analyzeButton").style.display = "none";
                    document.getElementById("circleX").style.display = "block";
                    document.getElementById("circleY").style.display = "block";
                    document.getElementById("circleSize").style.display = "block";
                    webSocket.send("hello server!");
                }

                webSocket.onmessage = (event) => {
                    if (typeof event.data == "string") {
                        console.log(event.data);
                    }
                    else if (typeof event.data == "object") {
                        handleCapture(event.data, true);
                    }
                }
            }
            catch (error) {
                console.error(error.message);
            }
        }

        (function () {
            //console.log("hello world");
        })();
    </script>
</body>

</html>